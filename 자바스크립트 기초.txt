Expression(표현식): 값을 표현하는 최소 단위
Statement(문장): 표현식으로 특정 결과물을 도출하는 표현식의 집합
Program: 특정 논리에 따라 의도한 결과물을 도출하기 위한 문장의 집합

변수
const: 블럭스코프 상수로 상수처리할 때 사용, 다시 말해, const에 저장된 내용은 변경되지 않음
let: 블럭스코프의 변수로 언제든 저장된 값에 대해 변경이 가능함
var: 함수스코프의 변수로 함수 안에서 블럭을 넘나들면서 접근이 가능
* 블럭스코프: 블럭 밖에서 안으로 접근은 가능하나, 하위 블럭 안에서 밖으로 접근은 불가능 

hoisitng 현상
특정 변수를 활용한 로직이 위에서 작성되고 아래서 해당 변수가 선언되어도 위의 로직에서 사용할 수 있는 기능
이는 오직 선언부만 끌어올 수 있는 것으로 아래서 선언된 변수에 특정 값이 저장되어도 저장된 값은 끌어올 수 없음
var의 경우 hoisting 현상 발생하나 let이나 const는 없음

동적타이핑
변수에 따른 고정 타입이 없음. 입력하는 변수에 따라 타입이 정해짐

템플릿 스트링
JS의 표현식을 활용 ? 정의를 구체화!

Symbol
고유한 값을 사용할 필요가 있을 때, 사용함. 같은값을 Symbol()에 넣어도 같지 않음.

삼항연산자
조건, ?, :
위의 세 가지로 조건식을 표현할 수 있음.
ex) let n = 5일 때, n % 5 === 0 ? '5의 배수' : '5의 배수 X'

for of
iterable한 자료형(배열) 대상으로 사용

for in 
객체 대상으로 사용, 의도에 맞지 않게 출력되기 쉬우므로 사용 시 주의

선언적 방식의 함수 정의 vs 익명 함수 정의
선언적으로 함수를 정의하면 해당 함수 사용 위치에 관계없이 사용가능
반면 익명 함수의 경우 정의부분이 사용 부분보다 위에 있어야 정상 사용 가능

일반 익명함수와 new 사용 익명함수의 차이
일반 익명함수 내부에서 같은 블럭스코프 안의 변수 접근 가능
new 사용 함수의 경우 같은 블럭스코프 안의 변수 접근 불가, 단 전역변수는 접근 가능

화살표 함수 사용 시 간략하게 표현 가능
const hello5 = name => `hello5 ${name}`;

익명함수(화살표 문법 포함)의 경우 this가 생성되지 않으므로 익명함수에서 this에 접근하기 위해서는 추가 조치가 필요함

생성자 함수
객체 생성 시, 익명함수는 사용이 불가함. 그 이유는 익명함수에는 객체 자신을 가리키는 this가 생성되지 않기 때문에 new를 이용해 인스턴스 생성이 불가함.
객체에 대한 정의를 담은 함수 생성 시, 익명이 아닌 선언적 함수를 사용한다.
ex) function Person(name, age) O, but const Cat = (name, age) =>{}  X

프로토타입 체인
생성자 함수 Person을 정의하고 이를 통해 person이라는 instance를 생성했다고 전제함. 
person은 Person의 instance이자 Object의 instance임. prototype은 Object에 딸려있는 것이므로
Person은 prototype 접근 가능함. 비록 Person 내부에 static으로 toString 메소드를 정의하지 않았더라도
prototype 내부의 toString 사용이 가능함. 
결과적으로 prototype에 의해 person.toString()이 가능함  

컴포넌트화 원리 이해하기
https://ko.reactjs.org/docs/thinking-in-react.html

this의 사용 in 선언적 방식의 함수 vs 익명 함수
- 선언적 방식의 함수에서 this는 함수를 호출한 객체 가리키는 반면
- 익명 함수에서 this는 익명 함수 스코프 밖을 가리킴 ? 그럼 Window나 다른걸 가리켜야 하는데 실제로 undefined로 표시됨...
+ 선언적 방식의 함수에서 함수를 호출한 객체를 가리키기 위해 that을 사용함

JSON(JavaScript Object Notation): standard text based format on 자바스크립트 객체 문법
JSON.stringify(자바스크립트객체): 자바스크립트 객체를 JSON 문자열로 변환 
JSON.parse(JSON 문자열): 위의 반대

AJAX(Asynchronous JavaScript And XML): XMLHttpRequest 객체를 사용하여 서버와 통신하는 것

동기성 vs 비동기성
동기성: 작업에 동시성 필요 시, request와 response가 특정 루틴을 모두 끝낸 후 제어권 반납 / ex) A노드에서 B노드로 계좌이체
비동기성: 동시성 불필요 시, 특정 루틴이 중 일부가 끝나지 않았어도 제어권 반납 후 일부 끝나지 않은 일을 지속 처리 ex) A노드, B노드 시험 문제 풀이, C노드 각각의 문제 채점하여 결과 도출 

GET vs POST
GET: header에 데이터가 실리므로 url에 데이터 노출됨. url 길이 제약과 보안 관련 정보 전달 부적절
POST: body에 데이터가 실리므로 url에 노출 X, 길이 제약 없으며 보안 부분 적절
